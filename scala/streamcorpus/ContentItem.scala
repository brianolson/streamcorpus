/**
 * generated by Scrooge ${project.version}
 */
package streamcorpus

import com.twitter.scrooge.{
  ThriftException, ThriftStruct, ThriftStructCodec3}
import org.apache.thrift.protocol._
import org.apache.thrift.transport.{TMemoryBuffer, TTransport}
import java.nio.ByteBuffer
import scala.collection.mutable
import scala.collection.{Map, Set}

/**
 * ContentItem contains raw data, an indication of its character
 * encoding, and various transformed versions of the raw data.
 */
object ContentItem extends ThriftStructCodec3[ContentItem] {
  val Struct = new TStruct("ContentItem")
  val RawField = new TField("raw", TType.STRING, 1)
  val EncodingField = new TField("encoding", TType.STRING, 2)
  val MediaTypeField = new TField("media_type", TType.STRING, 3)
  val CleanHtmlField = new TField("clean_html", TType.STRING, 4)
  val CleanVisibleField = new TField("clean_visible", TType.STRING, 5)
  val LogsField = new TField("logs", TType.LIST, 6)
  val TaggingsField = new TField("taggings", TType.MAP, 7)
  val LabelsField = new TField("labels", TType.MAP, 8)
  val SentencesField = new TField("sentences", TType.MAP, 9)
  val SentenceBlobsField = new TField("sentence_blobs", TType.MAP, 10)
  val LanguageField = new TField("language", TType.STRUCT, 11)
  val RelationsField = new TField("relations", TType.MAP, 12)
  val AttributesField = new TField("attributes", TType.MAP, 13)
  val ExternalIdsField = new TField("external_ids", TType.MAP, 14)

  /**
   * Checks that all required fields are non-null.
   */
  def validate(_item: ContentItem) {
  }

  override def encode(_item: ContentItem, _oproto: TProtocol) { _item.write(_oproto) }
  override def decode(_iprot: TProtocol): ContentItem = Immutable.decode(_iprot)

  def apply(
    raw: Option[ByteBuffer] = None,
    encoding: Option[String] = None,
    mediaType: Option[String] = None,
    cleanHtml: Option[String] = None,
    cleanVisible: Option[String] = None,
    logs: Seq[String] = Seq(),
    taggings: Map[String, Tagging] = Map(),
    labels: Map[String, Seq[Label]] = Map(),
    sentences: Map[String, Seq[Sentence]] = Map(),
    sentenceBlobs: Map[String, ByteBuffer] = Map(),
    language: Option[Language] = None,
    relations: Map[String, Seq[Relation]] = Map(),
    attributes: Map[String, Seq[Attribute]] = Map(),
    externalIds: Map[String, Map[Int, String]] = Map()
  ): ContentItem = new Immutable(
    raw,
    encoding,
    mediaType,
    cleanHtml,
    cleanVisible,
    logs,
    taggings,
    labels,
    sentences,
    sentenceBlobs,
    language,
    relations,
    attributes,
    externalIds
  )

  def unapply(_item: ContentItem): Option[Product14[Option[ByteBuffer], Option[String], Option[String], Option[String], Option[String], Seq[String], Map[String, Tagging], Map[String, Seq[Label]], Map[String, Seq[Sentence]], Map[String, ByteBuffer], Option[Language], Map[String, Seq[Relation]], Map[String, Seq[Attribute]], Map[String, Map[Int, String]]]] = Some(_item)

  object Immutable extends ThriftStructCodec3[ContentItem] {
    override def encode(_item: ContentItem, _oproto: TProtocol) { _item.write(_oproto) }
    override def decode(_iprot: TProtocol): ContentItem = {
      var raw: ByteBuffer = null
      var _got_raw = false
      var encoding: String = null
      var _got_encoding = false
      var mediaType: String = null
      var _got_mediaType = false
      var cleanHtml: String = null
      var _got_cleanHtml = false
      var cleanVisible: String = null
      var _got_cleanVisible = false
      var logs: Seq[String] = Seq()
      var _got_logs = false
      var taggings: Map[String, Tagging] = Map()
      var _got_taggings = false
      var labels: Map[String, Seq[Label]] = Map()
      var _got_labels = false
      var sentences: Map[String, Seq[Sentence]] = Map()
      var _got_sentences = false
      var sentenceBlobs: Map[String, ByteBuffer] = Map()
      var _got_sentenceBlobs = false
      var language: Language = null
      var _got_language = false
      var relations: Map[String, Seq[Relation]] = Map()
      var _got_relations = false
      var attributes: Map[String, Seq[Attribute]] = Map()
      var _got_attributes = false
      var externalIds: Map[String, Map[Int, String]] = Map()
      var _got_externalIds = false
      var _done = false
      _iprot.readStructBegin()
      while (!_done) {
        val _field = _iprot.readFieldBegin()
        if (_field.`type` == TType.STOP) {
          _done = true
        } else {
          _field.id match {
            case 1 => { /* raw */
              _field.`type` match {
                case TType.STRING => {
                  raw = {
                    _iprot.readBinary()
                  }
                  _got_raw = true
                }
                case _ => TProtocolUtil.skip(_iprot, _field.`type`)
              }
            }
            case 2 => { /* encoding */
              _field.`type` match {
                case TType.STRING => {
                  encoding = {
                    _iprot.readString()
                  }
                  _got_encoding = true
                }
                case _ => TProtocolUtil.skip(_iprot, _field.`type`)
              }
            }
            case 3 => { /* mediaType */
              _field.`type` match {
                case TType.STRING => {
                  mediaType = {
                    _iprot.readString()
                  }
                  _got_mediaType = true
                }
                case _ => TProtocolUtil.skip(_iprot, _field.`type`)
              }
            }
            case 4 => { /* cleanHtml */
              _field.`type` match {
                case TType.STRING => {
                  cleanHtml = {
                    _iprot.readString()
                  }
                  _got_cleanHtml = true
                }
                case _ => TProtocolUtil.skip(_iprot, _field.`type`)
              }
            }
            case 5 => { /* cleanVisible */
              _field.`type` match {
                case TType.STRING => {
                  cleanVisible = {
                    _iprot.readString()
                  }
                  _got_cleanVisible = true
                }
                case _ => TProtocolUtil.skip(_iprot, _field.`type`)
              }
            }
            case 6 => { /* logs */
              _field.`type` match {
                case TType.LIST => {
                  logs = {
                    val _list = _iprot.readListBegin()
                    if (_list.size == 0) {
                      _iprot.readListEnd()
                      Nil
                    } else {
                      val _rv = new mutable.ArrayBuffer[String](_list.size)
                      var _i = 0
                      while (_i < _list.size) {
                        _rv += {
                            _iprot.readString()
  
                        }
                        _i += 1
                      }
                      _iprot.readListEnd()
                      _rv
                    }
                  }
                  _got_logs = true
                }
                case _ => TProtocolUtil.skip(_iprot, _field.`type`)
              }
            }
            case 7 => { /* taggings */
              _field.`type` match {
                case TType.MAP => {
                  taggings = {
                    val _map = _iprot.readMapBegin()
                    if (_map.size == 0) {
                      _iprot.readMapEnd()
                      Map.empty[String, Tagging]
                    } else {
                      val _rv = new mutable.HashMap[String, Tagging]
                      var _i = 0
                      while (_i < _map.size) {
                        val _key = {
                            _iprot.readString()
  
                        }
                        val _value = {
                            Tagging.decode(_iprot)
  
                        }
                        _rv(_key) = _value
                        _i += 1
                      }
                      _iprot.readMapEnd()
                      _rv
                    }
                  }
                  _got_taggings = true
                }
                case _ => TProtocolUtil.skip(_iprot, _field.`type`)
              }
            }
            case 8 => { /* labels */
              _field.`type` match {
                case TType.MAP => {
                  labels = {
                    val _map = _iprot.readMapBegin()
                    if (_map.size == 0) {
                      _iprot.readMapEnd()
                      Map.empty[String, Seq[Label]]
                    } else {
                      val _rv = new mutable.HashMap[String, Seq[Label]]
                      var _i = 0
                      while (_i < _map.size) {
                        val _key = {
                            _iprot.readString()
  
                        }
                        val _value = {
                            val _list = _iprot.readListBegin()
                            if (_list.size == 0) {
                              _iprot.readListEnd()
                              Nil
                            } else {
                              val _rv = new mutable.ArrayBuffer[Label](_list.size)
                              var _i = 0
                              while (_i < _list.size) {
                                _rv += {
                                    Label.decode(_iprot)
  
                                }
                                _i += 1
                              }
                              _iprot.readListEnd()
                              _rv
                            }
  
                        }
                        _rv(_key) = _value
                        _i += 1
                      }
                      _iprot.readMapEnd()
                      _rv
                    }
                  }
                  _got_labels = true
                }
                case _ => TProtocolUtil.skip(_iprot, _field.`type`)
              }
            }
            case 9 => { /* sentences */
              _field.`type` match {
                case TType.MAP => {
                  sentences = {
                    val _map = _iprot.readMapBegin()
                    if (_map.size == 0) {
                      _iprot.readMapEnd()
                      Map.empty[String, Seq[Sentence]]
                    } else {
                      val _rv = new mutable.HashMap[String, Seq[Sentence]]
                      var _i = 0
                      while (_i < _map.size) {
                        val _key = {
                            _iprot.readString()
  
                        }
                        val _value = {
                            val _list = _iprot.readListBegin()
                            if (_list.size == 0) {
                              _iprot.readListEnd()
                              Nil
                            } else {
                              val _rv = new mutable.ArrayBuffer[Sentence](_list.size)
                              var _i = 0
                              while (_i < _list.size) {
                                _rv += {
                                    Sentence.decode(_iprot)
  
                                }
                                _i += 1
                              }
                              _iprot.readListEnd()
                              _rv
                            }
  
                        }
                        _rv(_key) = _value
                        _i += 1
                      }
                      _iprot.readMapEnd()
                      _rv
                    }
                  }
                  _got_sentences = true
                }
                case _ => TProtocolUtil.skip(_iprot, _field.`type`)
              }
            }
            case 10 => { /* sentenceBlobs */
              _field.`type` match {
                case TType.MAP => {
                  sentenceBlobs = {
                    val _map = _iprot.readMapBegin()
                    if (_map.size == 0) {
                      _iprot.readMapEnd()
                      Map.empty[String, ByteBuffer]
                    } else {
                      val _rv = new mutable.HashMap[String, ByteBuffer]
                      var _i = 0
                      while (_i < _map.size) {
                        val _key = {
                            _iprot.readString()
  
                        }
                        val _value = {
                            _iprot.readBinary()
  
                        }
                        _rv(_key) = _value
                        _i += 1
                      }
                      _iprot.readMapEnd()
                      _rv
                    }
                  }
                  _got_sentenceBlobs = true
                }
                case _ => TProtocolUtil.skip(_iprot, _field.`type`)
              }
            }
            case 11 => { /* language */
              _field.`type` match {
                case TType.STRUCT => {
                  language = {
                    streamcorpus.Language.decode(_iprot)
                  }
                  _got_language = true
                }
                case _ => TProtocolUtil.skip(_iprot, _field.`type`)
              }
            }
            case 12 => { /* relations */
              _field.`type` match {
                case TType.MAP => {
                  relations = {
                    val _map = _iprot.readMapBegin()
                    if (_map.size == 0) {
                      _iprot.readMapEnd()
                      Map.empty[String, Seq[Relation]]
                    } else {
                      val _rv = new mutable.HashMap[String, Seq[Relation]]
                      var _i = 0
                      while (_i < _map.size) {
                        val _key = {
                            _iprot.readString()
  
                        }
                        val _value = {
                            val _list = _iprot.readListBegin()
                            if (_list.size == 0) {
                              _iprot.readListEnd()
                              Nil
                            } else {
                              val _rv = new mutable.ArrayBuffer[Relation](_list.size)
                              var _i = 0
                              while (_i < _list.size) {
                                _rv += {
                                    Relation.decode(_iprot)
  
                                }
                                _i += 1
                              }
                              _iprot.readListEnd()
                              _rv
                            }
  
                        }
                        _rv(_key) = _value
                        _i += 1
                      }
                      _iprot.readMapEnd()
                      _rv
                    }
                  }
                  _got_relations = true
                }
                case _ => TProtocolUtil.skip(_iprot, _field.`type`)
              }
            }
            case 13 => { /* attributes */
              _field.`type` match {
                case TType.MAP => {
                  attributes = {
                    val _map = _iprot.readMapBegin()
                    if (_map.size == 0) {
                      _iprot.readMapEnd()
                      Map.empty[String, Seq[Attribute]]
                    } else {
                      val _rv = new mutable.HashMap[String, Seq[Attribute]]
                      var _i = 0
                      while (_i < _map.size) {
                        val _key = {
                            _iprot.readString()
  
                        }
                        val _value = {
                            val _list = _iprot.readListBegin()
                            if (_list.size == 0) {
                              _iprot.readListEnd()
                              Nil
                            } else {
                              val _rv = new mutable.ArrayBuffer[Attribute](_list.size)
                              var _i = 0
                              while (_i < _list.size) {
                                _rv += {
                                    Attribute.decode(_iprot)
  
                                }
                                _i += 1
                              }
                              _iprot.readListEnd()
                              _rv
                            }
  
                        }
                        _rv(_key) = _value
                        _i += 1
                      }
                      _iprot.readMapEnd()
                      _rv
                    }
                  }
                  _got_attributes = true
                }
                case _ => TProtocolUtil.skip(_iprot, _field.`type`)
              }
            }
            case 14 => { /* externalIds */
              _field.`type` match {
                case TType.MAP => {
                  externalIds = {
                    val _map = _iprot.readMapBegin()
                    if (_map.size == 0) {
                      _iprot.readMapEnd()
                      Map.empty[String, Map[Int, String]]
                    } else {
                      val _rv = new mutable.HashMap[String, Map[Int, String]]
                      var _i = 0
                      while (_i < _map.size) {
                        val _key = {
                            _iprot.readString()
  
                        }
                        val _value = {
                            val _map = _iprot.readMapBegin()
                            if (_map.size == 0) {
                              _iprot.readMapEnd()
                              Map.empty[Int, String]
                            } else {
                              val _rv = new mutable.HashMap[Int, String]
                              var _i = 0
                              while (_i < _map.size) {
                                val _key = {
                                    _iprot.readI32()
  
                                }
                                val _value = {
                                    _iprot.readString()
  
                                }
                                _rv(_key) = _value
                                _i += 1
                              }
                              _iprot.readMapEnd()
                              _rv
                            }
  
                        }
                        _rv(_key) = _value
                        _i += 1
                      }
                      _iprot.readMapEnd()
                      _rv
                    }
                  }
                  _got_externalIds = true
                }
                case _ => TProtocolUtil.skip(_iprot, _field.`type`)
              }
            }
            case _ =>
              TProtocolUtil.skip(_iprot, _field.`type`)
          }
          _iprot.readFieldEnd()
        }
      }
      _iprot.readStructEnd()
      new Immutable(
        if (_got_raw) Some(raw) else None,
        if (_got_encoding) Some(encoding) else None,
        if (_got_mediaType) Some(mediaType) else None,
        if (_got_cleanHtml) Some(cleanHtml) else None,
        if (_got_cleanVisible) Some(cleanVisible) else None,
        logs,
        taggings,
        labels,
        sentences,
        sentenceBlobs,
        if (_got_language) Some(language) else None,
        relations,
        attributes,
        externalIds
      )
    }
  }

  /**
   * The default read-only implementation of ContentItem.  You typically should not need to
   * directly reference this class; instead, use the ContentItem.apply method to construct
   * new instances.
   */
  class Immutable(
    val raw: Option[ByteBuffer] = None,
    val encoding: Option[String] = None,
    val mediaType: Option[String] = None,
    val cleanHtml: Option[String] = None,
    val cleanVisible: Option[String] = None,
    val logs: Seq[String] = Seq(),
    val taggings: Map[String, Tagging] = Map(),
    val labels: Map[String, Seq[Label]] = Map(),
    val sentences: Map[String, Seq[Sentence]] = Map(),
    val sentenceBlobs: Map[String, ByteBuffer] = Map(),
    val language: Option[Language] = None,
    val relations: Map[String, Seq[Relation]] = Map(),
    val attributes: Map[String, Seq[Attribute]] = Map(),
    val externalIds: Map[String, Map[Int, String]] = Map()
  ) extends ContentItem

  /**
   * This Proxy trait allows you to extend the ContentItem trait with additional state or
   * behavior and implement the read-only methods from ContentItem using an underlying
   * instance.
   */
  trait Proxy extends ContentItem {
    protected def _underlying_ContentItem: ContentItem
    def raw: Option[ByteBuffer] = _underlying_ContentItem.raw
    def encoding: Option[String] = _underlying_ContentItem.encoding
    def mediaType: Option[String] = _underlying_ContentItem.mediaType
    def cleanHtml: Option[String] = _underlying_ContentItem.cleanHtml
    def cleanVisible: Option[String] = _underlying_ContentItem.cleanVisible
    def logs: Seq[String] = _underlying_ContentItem.logs
    def taggings: Map[String, Tagging] = _underlying_ContentItem.taggings
    def labels: Map[String, Seq[Label]] = _underlying_ContentItem.labels
    def sentences: Map[String, Seq[Sentence]] = _underlying_ContentItem.sentences
    def sentenceBlobs: Map[String, ByteBuffer] = _underlying_ContentItem.sentenceBlobs
    def language: Option[Language] = _underlying_ContentItem.language
    def relations: Map[String, Seq[Relation]] = _underlying_ContentItem.relations
    def attributes: Map[String, Seq[Attribute]] = _underlying_ContentItem.attributes
    def externalIds: Map[String, Map[Int, String]] = _underlying_ContentItem.externalIds
  }
}

trait ContentItem extends ThriftStruct
  with Product14[Option[ByteBuffer], Option[String], Option[String], Option[String], Option[String], Seq[String], Map[String, Tagging], Map[String, Seq[Label]], Map[String, Seq[Sentence]], Map[String, ByteBuffer], Option[Language], Map[String, Seq[Relation]], Map[String, Seq[Attribute]], Map[String, Map[Int, String]]]
  with java.io.Serializable
{
  import ContentItem._

  def withoutPassthroughs(f: TField => Boolean) = this
  def withPassthroughs(pts: TraversableOnce[(TField, TTransport)]) = this

  def raw: Option[ByteBuffer]
  def encoding: Option[String]
  def mediaType: Option[String]
  def cleanHtml: Option[String]
  def cleanVisible: Option[String]
  def logs: Seq[String]
  def taggings: Map[String, Tagging]
  def labels: Map[String, Seq[Label]]
  def sentences: Map[String, Seq[Sentence]]
  def sentenceBlobs: Map[String, ByteBuffer]
  def language: Option[Language]
  def relations: Map[String, Seq[Relation]]
  def attributes: Map[String, Seq[Attribute]]
  def externalIds: Map[String, Map[Int, String]]

  def _1 = raw
  def _2 = encoding
  def _3 = mediaType
  def _4 = cleanHtml
  def _5 = cleanVisible
  def _6 = logs
  def _7 = taggings
  def _8 = labels
  def _9 = sentences
  def _10 = sentenceBlobs
  def _11 = language
  def _12 = relations
  def _13 = attributes
  def _14 = externalIds

  override def write(_oprot: TProtocol) {
    ContentItem.validate(this)
    _oprot.writeStructBegin(Struct)
    if (raw.isDefined) {
      val raw_item = raw.get
      _oprot.writeFieldBegin(RawField)
      _oprot.writeBinary(raw_item)
      _oprot.writeFieldEnd()
    }
    if (encoding.isDefined) {
      val encoding_item = encoding.get
      _oprot.writeFieldBegin(EncodingField)
      _oprot.writeString(encoding_item)
      _oprot.writeFieldEnd()
    }
    if (mediaType.isDefined) {
      val mediaType_item = mediaType.get
      _oprot.writeFieldBegin(MediaTypeField)
      _oprot.writeString(mediaType_item)
      _oprot.writeFieldEnd()
    }
    if (cleanHtml.isDefined) {
      val cleanHtml_item = cleanHtml.get
      _oprot.writeFieldBegin(CleanHtmlField)
      _oprot.writeString(cleanHtml_item)
      _oprot.writeFieldEnd()
    }
    if (cleanVisible.isDefined) {
      val cleanVisible_item = cleanVisible.get
      _oprot.writeFieldBegin(CleanVisibleField)
      _oprot.writeString(cleanVisible_item)
      _oprot.writeFieldEnd()
    }
    if (logs ne null) {
      val logs_item = logs
      _oprot.writeFieldBegin(LogsField)
      _oprot.writeListBegin(new TList(TType.STRING, logs_item.size))
      logs_item.foreach { logs_item_element =>
        _oprot.writeString(logs_item_element)
      }
      _oprot.writeListEnd()
      _oprot.writeFieldEnd()
    }
    if (taggings ne null) {
      val taggings_item = taggings
      _oprot.writeFieldBegin(TaggingsField)
      _oprot.writeMapBegin(new TMap(TType.STRING, TType.STRUCT, taggings_item.size))
      taggings_item.foreach { _pair =>
        val taggings_item_key = _pair._1
        val taggings_item_value = _pair._2
        _oprot.writeString(taggings_item_key)
        taggings_item_value.write(_oprot)
      }
      _oprot.writeMapEnd()
      _oprot.writeFieldEnd()
    }
    if (labels ne null) {
      val labels_item = labels
      _oprot.writeFieldBegin(LabelsField)
      _oprot.writeMapBegin(new TMap(TType.STRING, TType.LIST, labels_item.size))
      labels_item.foreach { _pair =>
        val labels_item_key = _pair._1
        val labels_item_value = _pair._2
        _oprot.writeString(labels_item_key)
        _oprot.writeListBegin(new TList(TType.STRUCT, labels_item_value.size))
        labels_item_value.foreach { labels_item_value_element =>
          labels_item_value_element.write(_oprot)
        }
        _oprot.writeListEnd()
      }
      _oprot.writeMapEnd()
      _oprot.writeFieldEnd()
    }
    if (sentences ne null) {
      val sentences_item = sentences
      _oprot.writeFieldBegin(SentencesField)
      _oprot.writeMapBegin(new TMap(TType.STRING, TType.LIST, sentences_item.size))
      sentences_item.foreach { _pair =>
        val sentences_item_key = _pair._1
        val sentences_item_value = _pair._2
        _oprot.writeString(sentences_item_key)
        _oprot.writeListBegin(new TList(TType.STRUCT, sentences_item_value.size))
        sentences_item_value.foreach { sentences_item_value_element =>
          sentences_item_value_element.write(_oprot)
        }
        _oprot.writeListEnd()
      }
      _oprot.writeMapEnd()
      _oprot.writeFieldEnd()
    }
    if (sentenceBlobs ne null) {
      val sentenceBlobs_item = sentenceBlobs
      _oprot.writeFieldBegin(SentenceBlobsField)
      _oprot.writeMapBegin(new TMap(TType.STRING, TType.STRING, sentenceBlobs_item.size))
      sentenceBlobs_item.foreach { _pair =>
        val sentenceBlobs_item_key = _pair._1
        val sentenceBlobs_item_value = _pair._2
        _oprot.writeString(sentenceBlobs_item_key)
        _oprot.writeBinary(sentenceBlobs_item_value)
      }
      _oprot.writeMapEnd()
      _oprot.writeFieldEnd()
    }
    if (language.isDefined) {
      val language_item = language.get
      _oprot.writeFieldBegin(LanguageField)
      language_item.write(_oprot)
      _oprot.writeFieldEnd()
    }
    if (relations ne null) {
      val relations_item = relations
      _oprot.writeFieldBegin(RelationsField)
      _oprot.writeMapBegin(new TMap(TType.STRING, TType.LIST, relations_item.size))
      relations_item.foreach { _pair =>
        val relations_item_key = _pair._1
        val relations_item_value = _pair._2
        _oprot.writeString(relations_item_key)
        _oprot.writeListBegin(new TList(TType.STRUCT, relations_item_value.size))
        relations_item_value.foreach { relations_item_value_element =>
          relations_item_value_element.write(_oprot)
        }
        _oprot.writeListEnd()
      }
      _oprot.writeMapEnd()
      _oprot.writeFieldEnd()
    }
    if (attributes ne null) {
      val attributes_item = attributes
      _oprot.writeFieldBegin(AttributesField)
      _oprot.writeMapBegin(new TMap(TType.STRING, TType.LIST, attributes_item.size))
      attributes_item.foreach { _pair =>
        val attributes_item_key = _pair._1
        val attributes_item_value = _pair._2
        _oprot.writeString(attributes_item_key)
        _oprot.writeListBegin(new TList(TType.STRUCT, attributes_item_value.size))
        attributes_item_value.foreach { attributes_item_value_element =>
          attributes_item_value_element.write(_oprot)
        }
        _oprot.writeListEnd()
      }
      _oprot.writeMapEnd()
      _oprot.writeFieldEnd()
    }
    if (externalIds ne null) {
      val externalIds_item = externalIds
      _oprot.writeFieldBegin(ExternalIdsField)
      _oprot.writeMapBegin(new TMap(TType.STRING, TType.MAP, externalIds_item.size))
      externalIds_item.foreach { _pair =>
        val externalIds_item_key = _pair._1
        val externalIds_item_value = _pair._2
        _oprot.writeString(externalIds_item_key)
        _oprot.writeMapBegin(new TMap(TType.I32, TType.STRING, externalIds_item_value.size))
        externalIds_item_value.foreach { _pair =>
          val externalIds_item_value_key = _pair._1
          val externalIds_item_value_value = _pair._2
          _oprot.writeI32(externalIds_item_value_key)
          _oprot.writeString(externalIds_item_value_value)
        }
        _oprot.writeMapEnd()
      }
      _oprot.writeMapEnd()
      _oprot.writeFieldEnd()
    }
    _oprot.writeFieldStop()
    _oprot.writeStructEnd()
  }

  def copy(
    raw: Option[ByteBuffer] = this.raw, 
    encoding: Option[String] = this.encoding, 
    mediaType: Option[String] = this.mediaType, 
    cleanHtml: Option[String] = this.cleanHtml, 
    cleanVisible: Option[String] = this.cleanVisible, 
    logs: Seq[String] = this.logs, 
    taggings: Map[String, Tagging] = this.taggings, 
    labels: Map[String, Seq[Label]] = this.labels, 
    sentences: Map[String, Seq[Sentence]] = this.sentences, 
    sentenceBlobs: Map[String, ByteBuffer] = this.sentenceBlobs, 
    language: Option[Language] = this.language, 
    relations: Map[String, Seq[Relation]] = this.relations, 
    attributes: Map[String, Seq[Attribute]] = this.attributes, 
    externalIds: Map[String, Map[Int, String]] = this.externalIds
  ): ContentItem =
    new Immutable(
      raw, 
      encoding, 
      mediaType, 
      cleanHtml, 
      cleanVisible, 
      logs, 
      taggings, 
      labels, 
      sentences, 
      sentenceBlobs, 
      language, 
      relations, 
      attributes, 
      externalIds
    )

  override def canEqual(other: Any): Boolean = other.isInstanceOf[ContentItem]

  override def equals(other: Any): Boolean = _root_.scala.runtime.ScalaRunTime._equals(this, other)

  override def hashCode: Int = _root_.scala.runtime.ScalaRunTime._hashCode(this)

  override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)


  override def productArity: Int = 14

  override def productElement(n: Int): Any = n match {
    case 0 => raw
    case 1 => encoding
    case 2 => mediaType
    case 3 => cleanHtml
    case 4 => cleanVisible
    case 5 => logs
    case 6 => taggings
    case 7 => labels
    case 8 => sentences
    case 9 => sentenceBlobs
    case 10 => language
    case 11 => relations
    case 12 => attributes
    case 13 => externalIds
    case _ => throw new IndexOutOfBoundsException(n.toString)
  }

  override def productPrefix: String = "ContentItem"
}