/**
 * generated by Scrooge 3.0.7-SNAPSHOT
 */
package streamcorpus

import com.twitter.scrooge.{ThriftException, ThriftStruct, ThriftStructCodec}
import org.apache.thrift.protocol._
import java.nio.ByteBuffer
import scala.collection.mutable
import scala.collection.{Map, Set}

/**
 * ContentItem contains raw data, an indication of its character
 * encoding, and various transformed versions of the raw data.
 */
object ContentItem extends ThriftStructCodec[ContentItem] {
  val Struct = new TStruct("ContentItem")
  val RawField = new TField("raw", TType.STRING, 1)
  val EncodingField = new TField("encoding", TType.STRING, 2)
  val MediaTypeField = new TField("mediaType", TType.STRING, 3)
  val CleanHtmlField = new TField("cleanHtml", TType.STRING, 4)
  val CleanVisibleField = new TField("cleanVisible", TType.STRING, 5)
  val LogsField = new TField("logs", TType.LIST, 6)
  val TaggingsField = new TField("taggings", TType.MAP, 7)
  val LabelsField = new TField("labels", TType.MAP, 8)
  val SentencesField = new TField("sentences", TType.MAP, 9)
  val SentenceBlobsField = new TField("sentenceBlobs", TType.MAP, 10)
  val LanguageField = new TField("language", TType.STRUCT, 11)
  val RelationsField = new TField("relations", TType.MAP, 12)

  /**
   * Checks that all required fields are non-null.
   */
  def validate(_item: ContentItem) {
  }

  def encode(_item: ContentItem, _oproto: TProtocol) { _item.write(_oproto) }
  def decode(_iprot: TProtocol) = Immutable.decode(_iprot)

  def apply(_iprot: TProtocol): ContentItem = decode(_iprot)

  def apply(
    raw: Option[ByteBuffer] = None,
    encoding: Option[String] = None,
    mediaType: Option[String] = None,
    cleanHtml: Option[String] = None,
    cleanVisible: Option[String] = None,
    logs: Seq[String] = Seq(),
    taggings: Map[String, Tagging] = Map(),
    labels: Map[String, Seq[Label]] = Map(),
    sentences: Map[String, Seq[Sentence]] = Map(),
    sentenceBlobs: Map[String, ByteBuffer] = Map(),
    language: Option[Language] = None,
    relations: Map[String, Seq[Relation]] = Map()
  ): ContentItem = new Immutable(
    raw,
    encoding,
    mediaType,
    cleanHtml,
    cleanVisible,
    logs,
    taggings,
    labels,
    sentences,
    sentenceBlobs,
    language,
    relations
  )

  def unapply(_item: ContentItem): Option[Product12[Option[ByteBuffer], Option[String], Option[String], Option[String], Option[String], Seq[String], Map[String, Tagging], Map[String, Seq[Label]], Map[String, Seq[Sentence]], Map[String, ByteBuffer], Option[Language], Map[String, Seq[Relation]]]] = Some(_item)

  object Immutable extends ThriftStructCodec[ContentItem] {
    def encode(_item: ContentItem, _oproto: TProtocol) { _item.write(_oproto) }
    def decode(_iprot: TProtocol) = {
      var raw: ByteBuffer = null
      var _got_raw = false
      var encoding: String = null
      var _got_encoding = false
      var mediaType: String = null
      var _got_mediaType = false
      var cleanHtml: String = null
      var _got_cleanHtml = false
      var cleanVisible: String = null
      var _got_cleanVisible = false
      var logs: Seq[String] = Seq()
      var _got_logs = false
      var taggings: Map[String, Tagging] = Map()
      var _got_taggings = false
      var labels: Map[String, Seq[Label]] = Map()
      var _got_labels = false
      var sentences: Map[String, Seq[Sentence]] = Map()
      var _got_sentences = false
      var sentenceBlobs: Map[String, ByteBuffer] = Map()
      var _got_sentenceBlobs = false
      var language: Language = null
      var _got_language = false
      var relations: Map[String, Seq[Relation]] = Map()
      var _got_relations = false
      var _done = false
      _iprot.readStructBegin()
      while (!_done) {
        val _field = _iprot.readFieldBegin()
        if (_field.`type` == TType.STOP) {
          _done = true
        } else {
          _field.id match {
            case 1 => { /* raw */
              _field.`type` match {
                case TType.STRING => {
                  raw = {
                    _iprot.readBinary()
                  }
                  _got_raw = true
                }
                case _ => TProtocolUtil.skip(_iprot, _field.`type`)
              }
            }
            case 2 => { /* encoding */
              _field.`type` match {
                case TType.STRING => {
                  encoding = {
                    _iprot.readString()
                  }
                  _got_encoding = true
                }
                case _ => TProtocolUtil.skip(_iprot, _field.`type`)
              }
            }
            case 3 => { /* mediaType */
              _field.`type` match {
                case TType.STRING => {
                  mediaType = {
                    _iprot.readString()
                  }
                  _got_mediaType = true
                }
                case _ => TProtocolUtil.skip(_iprot, _field.`type`)
              }
            }
            case 4 => { /* cleanHtml */
              _field.`type` match {
                case TType.STRING => {
                  cleanHtml = {
                    _iprot.readString()
                  }
                  _got_cleanHtml = true
                }
                case _ => TProtocolUtil.skip(_iprot, _field.`type`)
              }
            }
            case 5 => { /* cleanVisible */
              _field.`type` match {
                case TType.STRING => {
                  cleanVisible = {
                    _iprot.readString()
                  }
                  _got_cleanVisible = true
                }
                case _ => TProtocolUtil.skip(_iprot, _field.`type`)
              }
            }
            case 6 => { /* logs */
              _field.`type` match {
                case TType.LIST => {
                  logs = {
                    val _list = _iprot.readListBegin()
                    val _rv = new mutable.ArrayBuffer[String](_list.size)
                    var _i = 0
                    while (_i < _list.size) {
                      _rv += {
                        _iprot.readString()
                      }
                      _i += 1
                    }
                    _iprot.readListEnd()
                    _rv
                  }
                  _got_logs = true
                }
                case _ => TProtocolUtil.skip(_iprot, _field.`type`)
              }
            }
            case 7 => { /* taggings */
              _field.`type` match {
                case TType.MAP => {
                  taggings = {
                    val _map = _iprot.readMapBegin()
                    val _rv = new mutable.HashMap[String, Tagging]
                    var _i = 0
                    while (_i < _map.size) {
                      val _key = {
                        _iprot.readString()
                      }
                      val _value = {
                        Tagging.decode(_iprot)
                      }
                      _rv(_key) = _value
                      _i += 1
                    }
                    _iprot.readMapEnd()
                    _rv
                  }
                  _got_taggings = true
                }
                case _ => TProtocolUtil.skip(_iprot, _field.`type`)
              }
            }
            case 8 => { /* labels */
              _field.`type` match {
                case TType.MAP => {
                  labels = {
                    val _map = _iprot.readMapBegin()
                    val _rv = new mutable.HashMap[String, Seq[Label]]
                    var _i = 0
                    while (_i < _map.size) {
                      val _key = {
                        _iprot.readString()
                      }
                      val _value = {
                        val _list = _iprot.readListBegin()
                        val _rv = new mutable.ArrayBuffer[Label](_list.size)
                        var _i = 0
                        while (_i < _list.size) {
                          _rv += {
                            Label.decode(_iprot)
                          }
                          _i += 1
                        }
                        _iprot.readListEnd()
                        _rv
                      }
                      _rv(_key) = _value
                      _i += 1
                    }
                    _iprot.readMapEnd()
                    _rv
                  }
                  _got_labels = true
                }
                case _ => TProtocolUtil.skip(_iprot, _field.`type`)
              }
            }
            case 9 => { /* sentences */
              _field.`type` match {
                case TType.MAP => {
                  sentences = {
                    val _map = _iprot.readMapBegin()
                    val _rv = new mutable.HashMap[String, Seq[Sentence]]
                    var _i = 0
                    while (_i < _map.size) {
                      val _key = {
                        _iprot.readString()
                      }
                      val _value = {
                        val _list = _iprot.readListBegin()
                        val _rv = new mutable.ArrayBuffer[Sentence](_list.size)
                        var _i = 0
                        while (_i < _list.size) {
                          _rv += {
                            Sentence.decode(_iprot)
                          }
                          _i += 1
                        }
                        _iprot.readListEnd()
                        _rv
                      }
                      _rv(_key) = _value
                      _i += 1
                    }
                    _iprot.readMapEnd()
                    _rv
                  }
                  _got_sentences = true
                }
                case _ => TProtocolUtil.skip(_iprot, _field.`type`)
              }
            }
            case 10 => { /* sentenceBlobs */
              _field.`type` match {
                case TType.MAP => {
                  sentenceBlobs = {
                    val _map = _iprot.readMapBegin()
                    val _rv = new mutable.HashMap[String, ByteBuffer]
                    var _i = 0
                    while (_i < _map.size) {
                      val _key = {
                        _iprot.readString()
                      }
                      val _value = {
                        _iprot.readBinary()
                      }
                      _rv(_key) = _value
                      _i += 1
                    }
                    _iprot.readMapEnd()
                    _rv
                  }
                  _got_sentenceBlobs = true
                }
                case _ => TProtocolUtil.skip(_iprot, _field.`type`)
              }
            }
            case 11 => { /* language */
              _field.`type` match {
                case TType.STRUCT => {
                  language = {
                    streamcorpus.Language.decode(_iprot)
                  }
                  _got_language = true
                }
                case _ => TProtocolUtil.skip(_iprot, _field.`type`)
              }
            }
            case 12 => { /* relations */
              _field.`type` match {
                case TType.MAP => {
                  relations = {
                    val _map = _iprot.readMapBegin()
                    val _rv = new mutable.HashMap[String, Seq[Relation]]
                    var _i = 0
                    while (_i < _map.size) {
                      val _key = {
                        _iprot.readString()
                      }
                      val _value = {
                        val _list = _iprot.readListBegin()
                        val _rv = new mutable.ArrayBuffer[Relation](_list.size)
                        var _i = 0
                        while (_i < _list.size) {
                          _rv += {
                            Relation.decode(_iprot)
                          }
                          _i += 1
                        }
                        _iprot.readListEnd()
                        _rv
                      }
                      _rv(_key) = _value
                      _i += 1
                    }
                    _iprot.readMapEnd()
                    _rv
                  }
                  _got_relations = true
                }
                case _ => TProtocolUtil.skip(_iprot, _field.`type`)
              }
            }
            case _ => TProtocolUtil.skip(_iprot, _field.`type`)
          }
          _iprot.readFieldEnd()
        }
      }
      _iprot.readStructEnd()
      new Immutable(
        if (_got_raw) Some(raw) else None,
        if (_got_encoding) Some(encoding) else None,
        if (_got_mediaType) Some(mediaType) else None,
        if (_got_cleanHtml) Some(cleanHtml) else None,
        if (_got_cleanVisible) Some(cleanVisible) else None,
        logs,
        taggings,
        labels,
        sentences,
        sentenceBlobs,
        if (_got_language) Some(language) else None,
        relations
      )
    }
  }

  /**
   * The default read-only implementation of ContentItem.  You typically should not need to
   * directly reference this class; instead, use the ContentItem.apply method to construct
   * new instances.
   */
  class Immutable(
    val raw: Option[ByteBuffer] = None,
    val encoding: Option[String] = None,
    val mediaType: Option[String] = None,
    val cleanHtml: Option[String] = None,
    val cleanVisible: Option[String] = None,
    val logs: Seq[String] = Seq(),
    val taggings: Map[String, Tagging] = Map(),
    val labels: Map[String, Seq[Label]] = Map(),
    val sentences: Map[String, Seq[Sentence]] = Map(),
    val sentenceBlobs: Map[String, ByteBuffer] = Map(),
    val language: Option[Language] = None,
    val relations: Map[String, Seq[Relation]] = Map()
  ) extends ContentItem

  /**
   * This Proxy trait allows you to extend the ContentItem trait with additional state or
   * behavior and implement the read-only methods from ContentItem using an underlying
   * instance.
   */
  trait Proxy extends ContentItem {
    protected def _underlying_ContentItem: ContentItem
    def raw: Option[ByteBuffer] = _underlying_ContentItem.raw
    def encoding: Option[String] = _underlying_ContentItem.encoding
    def mediaType: Option[String] = _underlying_ContentItem.mediaType
    def cleanHtml: Option[String] = _underlying_ContentItem.cleanHtml
    def cleanVisible: Option[String] = _underlying_ContentItem.cleanVisible
    def logs: Seq[String] = _underlying_ContentItem.logs
    def taggings: Map[String, Tagging] = _underlying_ContentItem.taggings
    def labels: Map[String, Seq[Label]] = _underlying_ContentItem.labels
    def sentences: Map[String, Seq[Sentence]] = _underlying_ContentItem.sentences
    def sentenceBlobs: Map[String, ByteBuffer] = _underlying_ContentItem.sentenceBlobs
    def language: Option[Language] = _underlying_ContentItem.language
    def relations: Map[String, Seq[Relation]] = _underlying_ContentItem.relations
  }
}

trait ContentItem extends ThriftStruct
  with Product12[Option[ByteBuffer], Option[String], Option[String], Option[String], Option[String], Seq[String], Map[String, Tagging], Map[String, Seq[Label]], Map[String, Seq[Sentence]], Map[String, ByteBuffer], Option[Language], Map[String, Seq[Relation]]]
  with java.io.Serializable
{
  import ContentItem._

  def raw: Option[ByteBuffer]
  def encoding: Option[String]
  def mediaType: Option[String]
  def cleanHtml: Option[String]
  def cleanVisible: Option[String]
  def logs: Seq[String]
  def taggings: Map[String, Tagging]
  def labels: Map[String, Seq[Label]]
  def sentences: Map[String, Seq[Sentence]]
  def sentenceBlobs: Map[String, ByteBuffer]
  def language: Option[Language]
  def relations: Map[String, Seq[Relation]]

  def _1 = raw
  def _2 = encoding
  def _3 = mediaType
  def _4 = cleanHtml
  def _5 = cleanVisible
  def _6 = logs
  def _7 = taggings
  def _8 = labels
  def _9 = sentences
  def _10 = sentenceBlobs
  def _11 = language
  def _12 = relations

  override def write(_oprot: TProtocol) {
    ContentItem.validate(this)
    _oprot.writeStructBegin(Struct)
    if (raw.isDefined) {
      val raw_item = raw.get
      _oprot.writeFieldBegin(RawField)
      _oprot.writeBinary(raw_item)
      _oprot.writeFieldEnd()
    }
    if (encoding.isDefined) {
      val encoding_item = encoding.get
      _oprot.writeFieldBegin(EncodingField)
      _oprot.writeString(encoding_item)
      _oprot.writeFieldEnd()
    }
    if (mediaType.isDefined) {
      val mediaType_item = mediaType.get
      _oprot.writeFieldBegin(MediaTypeField)
      _oprot.writeString(mediaType_item)
      _oprot.writeFieldEnd()
    }
    if (cleanHtml.isDefined) {
      val cleanHtml_item = cleanHtml.get
      _oprot.writeFieldBegin(CleanHtmlField)
      _oprot.writeString(cleanHtml_item)
      _oprot.writeFieldEnd()
    }
    if (cleanVisible.isDefined) {
      val cleanVisible_item = cleanVisible.get
      _oprot.writeFieldBegin(CleanVisibleField)
      _oprot.writeString(cleanVisible_item)
      _oprot.writeFieldEnd()
    }
    if (true) {
      val logs_item = logs
      _oprot.writeFieldBegin(LogsField)
      _oprot.writeListBegin(new TList(TType.STRING, logs_item.size))
      logs_item.foreach { logs_item_element =>
        _oprot.writeString(logs_item_element)
      }
      _oprot.writeListEnd()
      _oprot.writeFieldEnd()
    }
    if (true) {
      val taggings_item = taggings
      _oprot.writeFieldBegin(TaggingsField)
      _oprot.writeMapBegin(new TMap(TType.STRING, TType.STRUCT, taggings_item.size))
      taggings_item.foreach { _pair =>
        val taggings_item_key = _pair._1
        val taggings_item_value = _pair._2
        _oprot.writeString(taggings_item_key)
        taggings_item_value.write(_oprot)
      }
      _oprot.writeMapEnd()
      _oprot.writeFieldEnd()
    }
    if (true) {
      val labels_item = labels
      _oprot.writeFieldBegin(LabelsField)
      _oprot.writeMapBegin(new TMap(TType.STRING, TType.LIST, labels_item.size))
      labels_item.foreach { _pair =>
        val labels_item_key = _pair._1
        val labels_item_value = _pair._2
        _oprot.writeString(labels_item_key)
        _oprot.writeListBegin(new TList(TType.STRUCT, labels_item_value.size))
        labels_item_value.foreach { labels_item_value_element =>
          labels_item_value_element.write(_oprot)
        }
        _oprot.writeListEnd()
      }
      _oprot.writeMapEnd()
      _oprot.writeFieldEnd()
    }
    if (true) {
      val sentences_item = sentences
      _oprot.writeFieldBegin(SentencesField)
      _oprot.writeMapBegin(new TMap(TType.STRING, TType.LIST, sentences_item.size))
      sentences_item.foreach { _pair =>
        val sentences_item_key = _pair._1
        val sentences_item_value = _pair._2
        _oprot.writeString(sentences_item_key)
        _oprot.writeListBegin(new TList(TType.STRUCT, sentences_item_value.size))
        sentences_item_value.foreach { sentences_item_value_element =>
          sentences_item_value_element.write(_oprot)
        }
        _oprot.writeListEnd()
      }
      _oprot.writeMapEnd()
      _oprot.writeFieldEnd()
    }
    if (true) {
      val sentenceBlobs_item = sentenceBlobs
      _oprot.writeFieldBegin(SentenceBlobsField)
      _oprot.writeMapBegin(new TMap(TType.STRING, TType.STRING, sentenceBlobs_item.size))
      sentenceBlobs_item.foreach { _pair =>
        val sentenceBlobs_item_key = _pair._1
        val sentenceBlobs_item_value = _pair._2
        _oprot.writeString(sentenceBlobs_item_key)
        _oprot.writeBinary(sentenceBlobs_item_value)
      }
      _oprot.writeMapEnd()
      _oprot.writeFieldEnd()
    }
    if (language.isDefined) {
      val language_item = language.get
      _oprot.writeFieldBegin(LanguageField)
      language_item.write(_oprot)
      _oprot.writeFieldEnd()
    }
    if (true) {
      val relations_item = relations
      _oprot.writeFieldBegin(RelationsField)
      _oprot.writeMapBegin(new TMap(TType.STRING, TType.LIST, relations_item.size))
      relations_item.foreach { _pair =>
        val relations_item_key = _pair._1
        val relations_item_value = _pair._2
        _oprot.writeString(relations_item_key)
        _oprot.writeListBegin(new TList(TType.STRUCT, relations_item_value.size))
        relations_item_value.foreach { relations_item_value_element =>
          relations_item_value_element.write(_oprot)
        }
        _oprot.writeListEnd()
      }
      _oprot.writeMapEnd()
      _oprot.writeFieldEnd()
    }
    _oprot.writeFieldStop()
    _oprot.writeStructEnd()
  }

  def copy(
    raw: Option[ByteBuffer] = this.raw, 
    encoding: Option[String] = this.encoding, 
    mediaType: Option[String] = this.mediaType, 
    cleanHtml: Option[String] = this.cleanHtml, 
    cleanVisible: Option[String] = this.cleanVisible, 
    logs: Seq[String] = this.logs, 
    taggings: Map[String, Tagging] = this.taggings, 
    labels: Map[String, Seq[Label]] = this.labels, 
    sentences: Map[String, Seq[Sentence]] = this.sentences, 
    sentenceBlobs: Map[String, ByteBuffer] = this.sentenceBlobs, 
    language: Option[Language] = this.language, 
    relations: Map[String, Seq[Relation]] = this.relations
  ): ContentItem = new Immutable(
    raw, 
    encoding, 
    mediaType, 
    cleanHtml, 
    cleanVisible, 
    logs, 
    taggings, 
    labels, 
    sentences, 
    sentenceBlobs, 
    language, 
    relations
  )

  override def canEqual(other: Any): Boolean = other.isInstanceOf[ContentItem]

  override def equals(other: Any): Boolean = runtime.ScalaRunTime._equals(this, other)

  override def hashCode: Int = runtime.ScalaRunTime._hashCode(this)

  override def toString: String = runtime.ScalaRunTime._toString(this)


  override def productArity: Int = 12

  override def productElement(n: Int): Any = n match {
    case 0 => raw
    case 1 => encoding
    case 2 => mediaType
    case 3 => cleanHtml
    case 4 => cleanVisible
    case 5 => logs
    case 6 => taggings
    case 7 => labels
    case 8 => sentences
    case 9 => sentenceBlobs
    case 10 => language
    case 11 => relations
    case _ => throw new IndexOutOfBoundsException(n.toString)
  }

  override def productPrefix: String = "ContentItem"
}