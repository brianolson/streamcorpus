/**
 * generated by Scrooge ${project.version}
 */
package streamcorpus

import com.twitter.scrooge.{
  ThriftException, ThriftStruct, ThriftStructCodec3}
import org.apache.thrift.protocol._
import org.apache.thrift.transport.{TMemoryBuffer, TTransport}
import java.nio.ByteBuffer
import scala.collection.mutable
import scala.collection.{Map, Set}

/**
 * Textual tokens identified by an NLP pipeline and marked up with
 * metadata from automatic taggers and possibly also Labels from
 * humans.
 */
object Token extends ThriftStructCodec3[Token] {
  val Struct = new TStruct("Token")
  val TokenNumField = new TField("token_num", TType.I32, 1)
  val TokenField = new TField("token", TType.STRING, 2)
  val OffsetsField = new TField("offsets", TType.MAP, 3)
  val SentencePosField = new TField("sentence_pos", TType.I32, 4)
  val LemmaField = new TField("lemma", TType.STRING, 5)
  val PosField = new TField("pos", TType.STRING, 6)
  val EntityTypeField = new TField("entity_type", TType.ENUM, 7)
  val MentionIdField = new TField("mention_id", TType.I32, 8)
  val EquivIdField = new TField("equiv_id", TType.I32, 9)
  val ParentIdField = new TField("parent_id", TType.I32, 10)
  val DependencyPathField = new TField("dependency_path", TType.STRING, 11)
  val LabelsField = new TField("labels", TType.MAP, 12)
  val MentionTypeField = new TField("mention_type", TType.ENUM, 13)

  /**
   * Checks that all required fields are non-null.
   */
  def validate(_item: Token) {
  }

  override def encode(_item: Token, _oproto: TProtocol) { _item.write(_oproto) }
  override def decode(_iprot: TProtocol): Token = Immutable.decode(_iprot)

  def apply(
    tokenNum: Int,
    token: String,
    offsets: Map[OffsetType, Offset] = Map(),
    sentencePos: Int = -1,
    lemma: Option[String] = None,
    pos: Option[String] = None,
    entityType: Option[EntityType] = None,
    mentionId: Int = -1,
    equivId: Int = -1,
    parentId: Int = -1,
    dependencyPath: Option[String] = None,
    labels: Map[String, Seq[Label]] = Map(),
    mentionType: Option[MentionType] = None
  ): Token = new Immutable(
    tokenNum,
    token,
    offsets,
    sentencePos,
    lemma,
    pos,
    entityType,
    mentionId,
    equivId,
    parentId,
    dependencyPath,
    labels,
    mentionType
  )

  def unapply(_item: Token): Option[Product13[Int, String, Map[OffsetType, Offset], Int, Option[String], Option[String], Option[EntityType], Int, Int, Int, Option[String], Map[String, Seq[Label]], Option[MentionType]]] = Some(_item)

  object Immutable extends ThriftStructCodec3[Token] {
    override def encode(_item: Token, _oproto: TProtocol) { _item.write(_oproto) }
    override def decode(_iprot: TProtocol): Token = {
      var tokenNum: Int = 0
      var _got_tokenNum = false
      var token: String = null
      var _got_token = false
      var offsets: Map[OffsetType, Offset] = Map()
      var _got_offsets = false
      var sentencePos: Int = -1
      var _got_sentencePos = false
      var lemma: String = null
      var _got_lemma = false
      var pos: String = null
      var _got_pos = false
      var entityType: EntityType = null
      var _got_entityType = false
      var mentionId: Int = -1
      var _got_mentionId = false
      var equivId: Int = -1
      var _got_equivId = false
      var parentId: Int = -1
      var _got_parentId = false
      var dependencyPath: String = null
      var _got_dependencyPath = false
      var labels: Map[String, Seq[Label]] = Map()
      var _got_labels = false
      var mentionType: MentionType = null
      var _got_mentionType = false
      var _done = false
      _iprot.readStructBegin()
      while (!_done) {
        val _field = _iprot.readFieldBegin()
        if (_field.`type` == TType.STOP) {
          _done = true
        } else {
          _field.id match {
            case 1 => { /* tokenNum */
              _field.`type` match {
                case TType.I32 => {
                  tokenNum = {
                    _iprot.readI32()
                  }
                  _got_tokenNum = true
                }
                case _ => TProtocolUtil.skip(_iprot, _field.`type`)
              }
            }
            case 2 => { /* token */
              _field.`type` match {
                case TType.STRING => {
                  token = {
                    _iprot.readString()
                  }
                  _got_token = true
                }
                case _ => TProtocolUtil.skip(_iprot, _field.`type`)
              }
            }
            case 3 => { /* offsets */
              _field.`type` match {
                case TType.MAP => {
                  offsets = {
                    val _map = _iprot.readMapBegin()
                    if (_map.size == 0) {
                      _iprot.readMapEnd()
                      Map.empty[OffsetType, Offset]
                    } else {
                      val _rv = new mutable.HashMap[OffsetType, Offset]
                      var _i = 0
                      while (_i < _map.size) {
                        val _key = {
                            OffsetType(_iprot.readI32())
  
                        }
                        val _value = {
                            Offset.decode(_iprot)
  
                        }
                        _rv(_key) = _value
                        _i += 1
                      }
                      _iprot.readMapEnd()
                      _rv
                    }
                  }
                  _got_offsets = true
                }
                case _ => TProtocolUtil.skip(_iprot, _field.`type`)
              }
            }
            case 4 => { /* sentencePos */
              _field.`type` match {
                case TType.I32 => {
                  sentencePos = {
                    _iprot.readI32()
                  }
                  _got_sentencePos = true
                }
                case _ => TProtocolUtil.skip(_iprot, _field.`type`)
              }
            }
            case 5 => { /* lemma */
              _field.`type` match {
                case TType.STRING => {
                  lemma = {
                    _iprot.readString()
                  }
                  _got_lemma = true
                }
                case _ => TProtocolUtil.skip(_iprot, _field.`type`)
              }
            }
            case 6 => { /* pos */
              _field.`type` match {
                case TType.STRING => {
                  pos = {
                    _iprot.readString()
                  }
                  _got_pos = true
                }
                case _ => TProtocolUtil.skip(_iprot, _field.`type`)
              }
            }
            case 7 => { /* entityType */
              _field.`type` match {
                case TType.I32 | TType.ENUM => {
                  entityType = {
                    streamcorpus.EntityType(_iprot.readI32())
                  }
                  _got_entityType = true
                }
                case _ => TProtocolUtil.skip(_iprot, _field.`type`)
              }
            }
            case 8 => { /* mentionId */
              _field.`type` match {
                case TType.I32 => {
                  mentionId = {
                    _iprot.readI32()
                  }
                  _got_mentionId = true
                }
                case _ => TProtocolUtil.skip(_iprot, _field.`type`)
              }
            }
            case 9 => { /* equivId */
              _field.`type` match {
                case TType.I32 => {
                  equivId = {
                    _iprot.readI32()
                  }
                  _got_equivId = true
                }
                case _ => TProtocolUtil.skip(_iprot, _field.`type`)
              }
            }
            case 10 => { /* parentId */
              _field.`type` match {
                case TType.I32 => {
                  parentId = {
                    _iprot.readI32()
                  }
                  _got_parentId = true
                }
                case _ => TProtocolUtil.skip(_iprot, _field.`type`)
              }
            }
            case 11 => { /* dependencyPath */
              _field.`type` match {
                case TType.STRING => {
                  dependencyPath = {
                    _iprot.readString()
                  }
                  _got_dependencyPath = true
                }
                case _ => TProtocolUtil.skip(_iprot, _field.`type`)
              }
            }
            case 12 => { /* labels */
              _field.`type` match {
                case TType.MAP => {
                  labels = {
                    val _map = _iprot.readMapBegin()
                    if (_map.size == 0) {
                      _iprot.readMapEnd()
                      Map.empty[String, Seq[Label]]
                    } else {
                      val _rv = new mutable.HashMap[String, Seq[Label]]
                      var _i = 0
                      while (_i < _map.size) {
                        val _key = {
                            _iprot.readString()
  
                        }
                        val _value = {
                            val _list = _iprot.readListBegin()
                            if (_list.size == 0) {
                              _iprot.readListEnd()
                              Nil
                            } else {
                              val _rv = new mutable.ArrayBuffer[Label](_list.size)
                              var _i = 0
                              while (_i < _list.size) {
                                _rv += {
                                    Label.decode(_iprot)
  
                                }
                                _i += 1
                              }
                              _iprot.readListEnd()
                              _rv
                            }
  
                        }
                        _rv(_key) = _value
                        _i += 1
                      }
                      _iprot.readMapEnd()
                      _rv
                    }
                  }
                  _got_labels = true
                }
                case _ => TProtocolUtil.skip(_iprot, _field.`type`)
              }
            }
            case 13 => { /* mentionType */
              _field.`type` match {
                case TType.I32 | TType.ENUM => {
                  mentionType = {
                    streamcorpus.MentionType(_iprot.readI32())
                  }
                  _got_mentionType = true
                }
                case _ => TProtocolUtil.skip(_iprot, _field.`type`)
              }
            }
            case _ =>
              TProtocolUtil.skip(_iprot, _field.`type`)
          }
          _iprot.readFieldEnd()
        }
      }
      _iprot.readStructEnd()
      new Immutable(
        tokenNum,
        token,
        offsets,
        sentencePos,
        if (_got_lemma) Some(lemma) else None,
        if (_got_pos) Some(pos) else None,
        if (_got_entityType) Some(entityType) else None,
        mentionId,
        equivId,
        parentId,
        if (_got_dependencyPath) Some(dependencyPath) else None,
        labels,
        if (_got_mentionType) Some(mentionType) else None
      )
    }
  }

  /**
   * The default read-only implementation of Token.  You typically should not need to
   * directly reference this class; instead, use the Token.apply method to construct
   * new instances.
   */
  class Immutable(
    val tokenNum: Int,
    val token: String,
    val offsets: Map[OffsetType, Offset] = Map(),
    val sentencePos: Int = -1,
    val lemma: Option[String] = None,
    val pos: Option[String] = None,
    val entityType: Option[EntityType] = None,
    val mentionId: Int = -1,
    val equivId: Int = -1,
    val parentId: Int = -1,
    val dependencyPath: Option[String] = None,
    val labels: Map[String, Seq[Label]] = Map(),
    val mentionType: Option[MentionType] = None
  ) extends Token

  /**
   * This Proxy trait allows you to extend the Token trait with additional state or
   * behavior and implement the read-only methods from Token using an underlying
   * instance.
   */
  trait Proxy extends Token {
    protected def _underlying_Token: Token
    def tokenNum: Int = _underlying_Token.tokenNum
    def token: String = _underlying_Token.token
    def offsets: Map[OffsetType, Offset] = _underlying_Token.offsets
    def sentencePos: Int = _underlying_Token.sentencePos
    def lemma: Option[String] = _underlying_Token.lemma
    def pos: Option[String] = _underlying_Token.pos
    def entityType: Option[EntityType] = _underlying_Token.entityType
    def mentionId: Int = _underlying_Token.mentionId
    def equivId: Int = _underlying_Token.equivId
    def parentId: Int = _underlying_Token.parentId
    def dependencyPath: Option[String] = _underlying_Token.dependencyPath
    def labels: Map[String, Seq[Label]] = _underlying_Token.labels
    def mentionType: Option[MentionType] = _underlying_Token.mentionType
  }
}

trait Token extends ThriftStruct
  with Product13[Int, String, Map[OffsetType, Offset], Int, Option[String], Option[String], Option[EntityType], Int, Int, Int, Option[String], Map[String, Seq[Label]], Option[MentionType]]
  with java.io.Serializable
{
  import Token._

  private[this] val EntityTypeFieldI32 = new TField("entity_type", TType.I32, 7)
  private[this] val MentionTypeFieldI32 = new TField("mention_type", TType.I32, 13)
  def withoutPassthroughs(f: TField => Boolean) = this
  def withPassthroughs(pts: TraversableOnce[(TField, TTransport)]) = this

  def tokenNum: Int
  def token: String
  def offsets: Map[OffsetType, Offset]
  def sentencePos: Int
  def lemma: Option[String]
  def pos: Option[String]
  def entityType: Option[EntityType]
  def mentionId: Int
  def equivId: Int
  def parentId: Int
  def dependencyPath: Option[String]
  def labels: Map[String, Seq[Label]]
  def mentionType: Option[MentionType]

  def _1 = tokenNum
  def _2 = token
  def _3 = offsets
  def _4 = sentencePos
  def _5 = lemma
  def _6 = pos
  def _7 = entityType
  def _8 = mentionId
  def _9 = equivId
  def _10 = parentId
  def _11 = dependencyPath
  def _12 = labels
  def _13 = mentionType

  override def write(_oprot: TProtocol) {
    Token.validate(this)
    _oprot.writeStructBegin(Struct)
    if (true) {
      val tokenNum_item = tokenNum
      _oprot.writeFieldBegin(TokenNumField)
      _oprot.writeI32(tokenNum_item)
      _oprot.writeFieldEnd()
    }
    if (token ne null) {
      val token_item = token
      _oprot.writeFieldBegin(TokenField)
      _oprot.writeString(token_item)
      _oprot.writeFieldEnd()
    }
    if (offsets ne null) {
      val offsets_item = offsets
      _oprot.writeFieldBegin(OffsetsField)
      _oprot.writeMapBegin(new TMap(TType.I32, TType.STRUCT, offsets_item.size))
      offsets_item.foreach { _pair =>
        val offsets_item_key = _pair._1
        val offsets_item_value = _pair._2
        _oprot.writeI32(offsets_item_key.value)
        offsets_item_value.write(_oprot)
      }
      _oprot.writeMapEnd()
      _oprot.writeFieldEnd()
    }
    if (true) {
      val sentencePos_item = sentencePos
      _oprot.writeFieldBegin(SentencePosField)
      _oprot.writeI32(sentencePos_item)
      _oprot.writeFieldEnd()
    }
    if (lemma.isDefined) {
      val lemma_item = lemma.get
      _oprot.writeFieldBegin(LemmaField)
      _oprot.writeString(lemma_item)
      _oprot.writeFieldEnd()
    }
    if (pos.isDefined) {
      val pos_item = pos.get
      _oprot.writeFieldBegin(PosField)
      _oprot.writeString(pos_item)
      _oprot.writeFieldEnd()
    }
    if (entityType.isDefined) {
      val entityType_item = entityType.get
      _oprot.writeFieldBegin(EntityTypeFieldI32)
      _oprot.writeI32(entityType_item.value)
      _oprot.writeFieldEnd()
    }
    if (true) {
      val mentionId_item = mentionId
      _oprot.writeFieldBegin(MentionIdField)
      _oprot.writeI32(mentionId_item)
      _oprot.writeFieldEnd()
    }
    if (true) {
      val equivId_item = equivId
      _oprot.writeFieldBegin(EquivIdField)
      _oprot.writeI32(equivId_item)
      _oprot.writeFieldEnd()
    }
    if (true) {
      val parentId_item = parentId
      _oprot.writeFieldBegin(ParentIdField)
      _oprot.writeI32(parentId_item)
      _oprot.writeFieldEnd()
    }
    if (dependencyPath.isDefined) {
      val dependencyPath_item = dependencyPath.get
      _oprot.writeFieldBegin(DependencyPathField)
      _oprot.writeString(dependencyPath_item)
      _oprot.writeFieldEnd()
    }
    if (labels ne null) {
      val labels_item = labels
      _oprot.writeFieldBegin(LabelsField)
      _oprot.writeMapBegin(new TMap(TType.STRING, TType.LIST, labels_item.size))
      labels_item.foreach { _pair =>
        val labels_item_key = _pair._1
        val labels_item_value = _pair._2
        _oprot.writeString(labels_item_key)
        _oprot.writeListBegin(new TList(TType.STRUCT, labels_item_value.size))
        labels_item_value.foreach { labels_item_value_element =>
          labels_item_value_element.write(_oprot)
        }
        _oprot.writeListEnd()
      }
      _oprot.writeMapEnd()
      _oprot.writeFieldEnd()
    }
    if (mentionType.isDefined) {
      val mentionType_item = mentionType.get
      _oprot.writeFieldBegin(MentionTypeFieldI32)
      _oprot.writeI32(mentionType_item.value)
      _oprot.writeFieldEnd()
    }
    _oprot.writeFieldStop()
    _oprot.writeStructEnd()
  }

  def copy(
    tokenNum: Int = this.tokenNum, 
    token: String = this.token, 
    offsets: Map[OffsetType, Offset] = this.offsets, 
    sentencePos: Int = this.sentencePos, 
    lemma: Option[String] = this.lemma, 
    pos: Option[String] = this.pos, 
    entityType: Option[EntityType] = this.entityType, 
    mentionId: Int = this.mentionId, 
    equivId: Int = this.equivId, 
    parentId: Int = this.parentId, 
    dependencyPath: Option[String] = this.dependencyPath, 
    labels: Map[String, Seq[Label]] = this.labels, 
    mentionType: Option[MentionType] = this.mentionType
  ): Token =
    new Immutable(
      tokenNum, 
      token, 
      offsets, 
      sentencePos, 
      lemma, 
      pos, 
      entityType, 
      mentionId, 
      equivId, 
      parentId, 
      dependencyPath, 
      labels, 
      mentionType
    )

  override def canEqual(other: Any): Boolean = other.isInstanceOf[Token]

  override def equals(other: Any): Boolean = _root_.scala.runtime.ScalaRunTime._equals(this, other)

  override def hashCode: Int = _root_.scala.runtime.ScalaRunTime._hashCode(this)

  override def toString: String = _root_.scala.runtime.ScalaRunTime._toString(this)


  override def productArity: Int = 13

  override def productElement(n: Int): Any = n match {
    case 0 => tokenNum
    case 1 => token
    case 2 => offsets
    case 3 => sentencePos
    case 4 => lemma
    case 5 => pos
    case 6 => entityType
    case 7 => mentionId
    case 8 => equivId
    case 9 => parentId
    case 10 => dependencyPath
    case 11 => labels
    case 12 => mentionType
    case _ => throw new IndexOutOfBoundsException(n.toString)
  }

  override def productPrefix: String = "Token"
}